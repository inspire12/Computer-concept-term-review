# 프로그래밍의 정석
지식의 토대
# 전제 - 프로그래밍 불변의 사실  
## 프로그래밍에서 만능은 없다
* What? 특효약은 없다 - 상황에 맞게

* Why? 소프트웨어는 본질적으로 난해하다
  * 복잡성
  * 동조성(호환성) <br>
  소프트웨어는 실세계와 계속 동조해야한다
  * 가변성(변경 가능성)
  * 비가시성  
* How? 역사를 배워 복잡함에 맞선다<br>
  착실하고 과학적인 접근법에 근거하여 개선해야한다.<br>
  소프트웨어 본질은 난해성이며 최대 요인은 복잡함에 있다.<br> 소프트웨어 개발 역사는 사실 복잡함과 투쟁의 역사
* improve 소프트웨어의 비본질적인 부분을 개선
  * 부차적이고 부수적인 것들 ex) 빌드환경, 프로그래밍 언어, 라이브러리, 프레임워크  이들을 자동화해서 본질적인 부분에 시간을 더 할애하자  

## 코드는 설계서다
* What? 코드가 곧 설계서
  설계의 결과물인 설계서가 코드다.<br>
  제조에 해당하는 공정은 배포와 빌드다. <br>
  컴파일러와 빌드 시스템이 수행하는 것
* Why? 개선 대상은 코드다
  기본 설계, 상세 설계, 프로그래밍, 테스트, 디버깅은 나눌 수 없는 한 묶음의 작업 단위다. 서로 연계되어있다.
* How? 우수한 설계자(=프로그래머)가 필요
  * 프로그래밍은 창조적인 행위
  한 묶음의 작업이라면 그런 작업을 분담하는 것이 바람직한 방식은 아니다. 모든 프로그래머가 사양을 작성하고 코드를 작성해야한다.  
  * 프로그래밍 언어에 종속되지 않은 설계 표기를 나중에 누군가가 코드로 변환시키보다는 설계자 본인이 직접하는게 제대로된 방식
  * 코드 작성을 가능한 빨리 시작해야 불명확한 부분을 채우고 설계가 완성된다.
* 로제타 스톤 - 문서도 중요하다  
  * 장래의 유지보수 담당자에게 필요한 가이드북
  * 소프트웨어 아키텍처에 ㅎ관해서 전체를 파악하기 위해 필요한 그림을 기술 and 설계 이유(why)를 작성
## 코드는 반드시 변경된다
* What? 코드는 수정되는 법, 일회용으로 쓰고 버리는 경우는 우선 없다.
* Why? 코드는 무상하다
  * 본질적으로 복잡하며 완벽해질 수 없다.
  * 배포된 후에 반드시 오류가 발생하고 문제를 해결해야한다. 기능을 확장할 때도 있다. 최초 배포만으로 요구사항을 완전히 망라한 소프트웨어를 만들어 내는 것은 불가능하다.
* ### How? 변경에 강한 코드를 작성한다.
  * 읽기 쉬워야한다.

# 원칙 - 프로그래밍 가이드 라인
## KISS -Keep It Simple, Stupid /Keep It Short and Simple
  * What? 코드는 단순하게 유지한다.
  * Why? 코드는 무질서로 향한다.
    * 코드는 반드시 변경이 된다.
    * 단순한 코드는 구성하는 각 요소가 모두 단순하고 각 요소가 담당하는 기능도 최소한으로 한정되어 있다.
  * How? 코드에 불필요한 것을 하지 않는다.<br>
    불필요한 것을 키우는 마인드
    * 새롭게 배운 기술을 사용하고 싶다
    * 장래의 필요에 대비하고 싶다
    * 멋대로 요구사항을 추가한다
    요구사항을 결정하는 건 사용자다
  * KISS 적용 범위<br>
    기능만 많고 복잡한 소프트웨어는 결국 사용하지 않는다. 기능과 인터페이스를 단순하게 유지하면 사용하기 쉽고 많이 사용하는 소프트웨어가 된다.
  * 오컴의 면도날<br>
  '어떤 사항을 설명하는데 필요 이상으로 많은 전제를 가정해서는 안된다는 사고방식' 여러 설명이 가능하다면 가장 단순한 방식이 옳다는 뜻

## DRY - Don't Repeat Yourself 중복하지 마라
* What? 코드 복사는 금물
* 코드를 개선할 수 없다.
* 레거시 코드 : 테스트가 없는 코드// 예전에는 만들어진 이해할 수 없고 변경 어려운 코드에서 재정의

## YAGNI - You Aren't Going to Need it
* What? 코드는 필요할 때 최소한으로, 정말로 필요해졌을 때 필요한 코드만을 작성한다는 방침  
* 코드의 예측은 빗나간다.
* 코드는 지금 필요한 것만

## PIE - Program Intently and Expressively
* What? 코드의 의도를 전한다.
* 코드가 유일한 실마리
* 코드는 읽기 쉬운 것이 최우선
* 두더지 잡기식 개발을 피한다
* 주석을 작성한다. - 코드는 what, how 밖에 표현 못하므로
* 문화적 프로그래밍
 코드 자체를 문서화하는 기법, 코드는 스토리처럼 작성

## SLAP - Single Level of Abstraction Principle
* What? 코드 수준을 맞춘다. (추상)
코드를 작성할 때 높은 수준의 추상화 개념과 낮은 수준의 추상화 개념을 분리하도록 한다. <br>

```
function 고수준(){
  중수준1();
  중수준2();
}
function 중수준1(){
  저수준1();
  저수준2();
}
function 저수준1(){
  //처리
}
```
* 코드에 요약성과 열람성을 가져다준다.
* 함수를 구조화한다
* 의도가 구조
* SLAP의 순서
  - <Strong>내용을 쓰는 것과 내용을 이해하기 쉽게 전하기 위한 구성을 생각하는 것</Strong>은 별개
* 코드와 책의 유사성
  * 서문 : 책의 요지, 파일 첫머리 주석  
  * 목차 // 함수 목록, ide가 제공하니 불필요
  * 섹션 : 모듈 단위 기술
  * 장 : 구조화한 함수
  * 단락 : 코드 블록
  * 문장 : 실제 구현, 간결해야
  * 상호 참조 및 색인

## OCP - Open-Closed Principle
코드의 변경은 다른 부분으로 파급하지 않는다 <br>
OCP에 위반하지 않은 설계를 할 때 가장 중요한 것은 무엇이 변하는 것인지, 무엇이 변하지 않는 것인지를 구분해야 한다는 점이다.<br>
변해야 하는 것은 쉽게 변할 수 있게 하고, 변하지 않아야 할 것은 변하는 것에 영향을 받지 않게 해야 한다.<br>
ex) 코드에 인터페이스를 사용한다. 이를 통해 서버의 변경이 클라이언트의 변경에 영향을 주지 않도록 해야한다. <br>
'다형성' => 스트레티지 패턴, 옵저버 패턴, 템플릿 메서드 패턴, 데코레이터 패턴

## 명명이 중요하다
* What? 코드에서 명명은 가장 중요한 과제
* Why? 코드를 읽는 사람에 대한 사용자 인터페이스
* How? 코드는 우선 이름을 정한다.
* 루프백
이름 가역성 (설명 -> 이름 -> 설명)으로 돌아왔을 때 설명이 일치하면 좋은 이름

# 사상 - 프로그래밍 이데올로기
## 프로그래밍 이론
* What? 가치관 의사소통 / 단순함 / 유연성
* Why? 가치관을 기술의 선택 기준으로 (적용 기준)
  - 어째서 이런 것을 해야하나, 이것에 어떤 가치가 있나, 언제 쓰면 좋은가
* 가치관은 원칙을 통해 코드에 적용 (결과의 국소화, 반복의 최소화, 로직과 데이터의 일체화, 대칭성, 선언형의 표현, 변경 빈도)
* 포스 : 기술을 적용할 때 고려해야 할 관점
* 지금 쓰는 도구는 왜 이런 형태가 되었을까?

## 의사소통
* 코드는 의사소통의 장
* 소프트웨어 개발 비용은 대부분 유지보수 비용 - 쓰는 것보다 읽는 게 더 오래걸린다
* How? : 코드를 읽는 쪽의 관점에서 전환하라

## 단순함
* What? 코드의 복잡성은 제거한다.  
* Why? 복잡성이 화근
* How? 코드의 옥석을 구분한다.

## 유연성
* What? 코드 변경이 용이
* Why? 코드는 반드시 변경된다.
* How? 코드 확장성 - 복잡한 코드나 설계가 정당화될 우려, 단순함에서 시작해 단위 테스트를 통해 상향식으로 얻어지는 유연성!

## 결과의 국소화
* 변경에 영향을 억제
* 수정과 확인이 쉽도록
* How? 관계가 밀접한 코드를 한데 모은다.

## 반복의 최소화  
* 중복을 제거
* 반복 코드는 결과의 국소화를 침해  
* How? 코드를 분할해서 관리

## 대칭성 ?
 추가 메서드가 있다면 대응하는 삭제 메서드를 작성

## 선언형의 표현
* Why? 흐름이 없어야 읽기 쉽다. - 선언형 코드는 순서나 조건 분기가 없어 상태와 제약, 데이터 흐름을 쫓을 필요가 없다.
* How? 선언형 코드를 도입해 단순하게 의도를 표현 - annotation

## 변경 빈도

* 단일 책임의 원칙

## 아키텍처 기본 기법
* What? 좋은 코드의 기초 원리 10개
  * 추상 / 캡슐화 / 정보은닉 / 패키지화 /관심 분리 / 충족성, 완전성, 프리미티브성 / 정책과 구현의 분리 / 인터페이스와 구현의 분리 / 참조의 단일성 / 분할 정복
* 좋은 코드에는 품새가 있다 (패턴)

## 추상  
* What? 개념적인 선 긋기  추상은 `사상` 과 `일반화` 2가지 관점에서 정리  
  * 사상 : 복잡한 대상의 몇 가지 성질을 버리고 특정한 성질에 주목
  * 일반화 : 구체적인 대상으로부터 공통 성질을 추출해서 더욱 범용적인 개념으로 정식화하는 것
* Why? (복잡함에 대한 대항 수단)
* How?

## 로직과 데이터의 일체화
* What?
* Why?
* How?

## 캡슐화
* What?
* Why?
* How?

## 정보 은닉
* What?
* Why?
* How?

## 패키지화
* What? 모듈을 그룹핑
* Why?
* How?

## 관심의 분리
* What?
* Why?
* How?

## 충족성, 완전성, 순수성
* What? 표현이 충분하고 완벽하면서 순수
* Why?
* How?

## 정책과 구현의 분리
* What? 정책과 구현은 섞지 않는다
* Why?
* How?

## 인터페이스와 구현의 분리
* What?
* Why?
* How?

## 참조의 단일성
* What?
* Why?
* How?

## 아키텍처 비기능 요구사항
* What? 기능 외적인 기능이라는 관점
* Why?
* How?

## 7가지 설계 원리
## UNIX 사상
## UNIX 철학

# 관점 - 프로그래머가 보는 시각
'이런 관점으로 생각하고 이런 요소를 고려해 두면 나중에 좋다'
## 응집도
* What?
* Why?
* How?

## 결합도
* What?
* Why?
* How?

## 직교성
* What?
* Why?
* How?

## 가역성
* What? Undo 가능한 선택을 하라
* Why? 최종 결정 따위는 없다
* How?

## 코드의 구린내
* What?
* Why?
* How?

## 기술적 부채
* What? 지저분한 코드가 쌓여가는 걸 기술적 부채라고 함
* Why?
* How? 문제 있는 코드를 관리한다
* Imp? 문제 있는 코드의 원인
  * 경험이 부족
  * 마감 압박
  * 읽기 어려운 코드
  * 전문화된 코드
  * 불필요하게 복잡한 코드
  * 그냥 나쁜 설계
  * 안이하게 코드를 분기 관리

# 습관 - 프로그래머의 일상
## 3대 미덕
* What? 태만, 성급, 오만
* Why?
  * 태만 - 반복되는 업무를 자동화
  * 성급 - 컴퓨터가 원하는 동작을 해주지 않으면 코드를 바꿔 생각한대로 동작하도록 함
  * 오만 - 누가 보다라도 부끄럽지 않게끔 작성  
* How?

** 프로그래머한테 중노동은 의미가 없다..  -> 업무에 몰입하고 효율화 될수록 필요한 시간이 짧아진다

## 보이 스카우트 규칙
* What? 코드를 청소하고 돌아간다 - 자기가 머물렀던 자리를 떠날 때는 자기가 왔을 때보다 깨끗이 치워야한다.
* Why?
* How?

## 성능 튜닝에 관한 금언
* What? 빠른보다 좋은 코드
* WHy? 빠른 코드는 수지가 맞지 않는다 - 가독성, 품질, 복잡성, 보수, 환경간 경합, 작업량 증대
* How? 우선 좋은 코드를 작성한 다음에 필요에 따라 성능 튜닝을 수행
* Imp? 소프트웨어의 성능
  * 실행 환경
  * 배치 또는 설치 설정
  * 사용하고 있는 미들웨어
  * 사용하고 있는 라이브러리
  * 상호 운용하고 있는 구 시스템
  * 아키텍처

* 성능 튜닝의 순서

# 기법 - 프로그래머의 도구 상자
## 예광탄 - 탄도의 궤적을 알 수 있게끔 만들어진 탄환
* What? 최종 형태에도 남는 골격 코드
* Why? 최종형태에 대한 결정을 신속하고 눈에 보이는 형태로 반복 제시할 수 있어야 한다 - 샘플 소프트웨어
* How? 최초 단계에 동작하는 토대를 만든다 - 소프트웨어 전체가 어떤 식으로 연계되는지 명확히 (프로토타입과는 다름)
## 계약에 의한 설계
* What? 호출하는 쪽과 호출받는 쪽의 약속

* Why? 착오의 조기 발견
올바른 코드란 요구되는 것 이상도, 이하도 수행하지 않는 코드
* How?
## 방어적 프로그래밍
* What?
* Why?
* How?
## 개밥 먹기
* What? 소프트웨어 맛보기
* Why? 사용자의 관점을 얻는다.
* How?
## 고무오리
* What? 누군가에게 코드를 설명하며 스스로 깨우지는 것
* Why?
* How?
## 컨텍스트
* What? 문맥 대화와 문맥 사고
코드의 읽고 쓰기는 코드 작성한 사람과 코드를 읽는 사람간의 대화 / 생각의 도구로 사용
* Why?
* How?
 시스템 사고와 도메인 주도 설계



# 법칙 - 프로그래밍 안티 패턴
소프트웨어를 개발할 때 빠지기 쉬운 함정들
## 브룩스의 법칙
* What?
* Why?
* How?

## 콘웨이의 법칙
* What? 아키텍처는 조직을 반영한다
* Why?
* How?
## 엔트로피 증가의 법칙
* What? 코드는 저절로 썩어간다
* Why?
* How?

3줄 요약
1. 올바른 코드란 요구되는 것 이상도 이하도 하지 않는 코드
2. 확장할 부분과 닫을 부분을 고려해 나누고 유연성 때문에 복잡하게 만들지말자
3. 누가 봐도 보기 좋게 단순하고 명쾌하게
